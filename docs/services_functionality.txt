SERVICE: movie search
    Frontend: /search, /search/results?<query>
        /search: form to search for a movie. 
            Search terms passed to API for add_to_index
            Redirects to /search/results/
        /search/results?<query>
            Shows links formatted as hyperlinks for <a>Movie Name (YYYY)</a>, most relevant results first
            If no results, say "Sorry! We couldn't find <reproduce query>"

    Logic:
        init_search_db()
            Initializes search database.
        get_search_db()
            Helper function to open search database
        add_to_index(movie_id, movie_name, movie_year, ...)
            Adds a movie to ElasticSearch index.
        search_db(search_terms)
            Sends query to ElasticSearch database and returns movie_id and movie_name as results
    Database: ElasticSearch


SERVICE: User management
    Frontend: /login, /register, /logout
        If user is logged out, have links for "Register" and "Log in" at the top of any accessible page
        If user is logged in, have link for "Log Out" instead in that same location
    
    Logic: redirects to OAuth2 and then hands back results to other functions.
        init_user_db()
        get_user_db()
        add_user()

    Database: SQLite3 user database

SERVICE: View movie data
    Frontend: /view/<movie_id>
        Show movie poster, movie name, movie year of release, and description text for <movie_id>
        Seen status section:
            If user is logged in and movie is marked as "seen", write "You have seen this movie" and have an link for "Mark unseen"
            If user is logged in and movie is marked as "unseen", write "You have not seen this movie" and have a link for "Mark seen"
            If user is logged in and movie is neither seen nor unseen, include linkes for both "Mark seen" and "Mark unseen"
            If user is not logged in or if UserMovie service is unreachable, exclude this section.

    Logic:
        get_movie_data(movie_id)

    Database: SQLite 3 movie database
    File store: Static files (for now)


SERVICE: UserMovie data
    Frontend: /compare, /list

    Logic: 
        has_user_seen(user_id, movie_id)
            Queries database (or cache)
            Returns True, False, or None.
        mark_seen(user_id, movie_id)
            If user has already seen the movie, does nothing.
            If user has movie marked as Unseen, remove that mark, then mark as Seen.
            If user has movie unmarked, mark as seen.
        mark_unseen(user_id, movie_id)
            If user has not marked the film, mark it as unseen.
            If user has marked the film as unseen, do nothing.
            If user has marked the film as seen, remove all IS_PREFERRED_TO{by:user} connections between film and other films.
        get_seen_set(user_id)
            Queries the database.
            Returns a set of movie_ids (unsorted) which the user has marked as seen.
        get_subgraph(user_id, movie_id, up:bool=False)
            Returns a set of all movies in the subgraph of movie_id for user; all movies for which movie_id is indirectly preferred.
            If parameter up==True, then returns the reverse subgraph; all movies that are indirectly preferred to movie_id.
        check_valid_preference(user_id, movie_1, movie_2)
            Check if inserting a preference for movie_1 over movie_2 would be valid using a cycle detection algorithm.
        get_movie_comparisons(user_id)
            Using get_seen_set and get_subgraph, iteratively select film pairs such that if all comparisons were made there would be no way for a cycle to form.
            (Note: this does not replace the "check" function as concurrent logins could create cycles.)
        insert_preference(user_id, movie_1, movie_2)
            Call check_valid_preference, and if valid, add to the graph.
        topological_list(user_id)
            List all movies in a topologically sorted order.
            Do this as a BFS, bottom-up; so, listing all movies which are preferred over nothing first
            Then reverse, so that you have the movies with the largest subgraphs at the top

    Database: Neo4j